+++
title = "defconst, defvar, defcustomの使い分け"
author = ["karuta"]
publishDate = 2021-06-22T00:00:00+09:00
tags = ["elisp"]
draft = true
+++

elispで変数を扱うというと、 `setq` がはじめに紹介される。しかし、変数っていうくくりだと他にもあり、使い分けに混乱するので整理する  

<!--more-->  


## defvar {#defvar}

`defvar` はライブラリを作る際に、グルーバル変数を始めに定義するために使用する。  
`setq` でも変数として使用できるが、どこで定義されたかわかりにくいので変数を宣言しておこうという意味で使用される。  

```elisp
(defvar a)
a ;; => nil
(setq a 1)
a ;; => 1
```

ここでは変数 `a` は初期値nilの変数であり、その後 `setq` によって1が代入されている。ちなみにどうしてグローバルに変数定義するのか参考サイトに整理されている。  

> 1番目は、コードを読む人にたいして、そのシンボルが特定の方法(変数として)使用されることを意図したものだと知らせることです。  
> 2番目は、Lispシステムにたいして、オプションで初期値とドキュメント文字列を与えて、これを知らせることです。  
> 3番目は、etagsのようなプログラミングツールにたいして、その変数が定義されている場所を見つけられるように、情報を提供することです。  

1番目は上に自分が書いたことである。  
2番目は、LISPらしく変数宣言のときにも変数に対して次のように説明がつけられる  

```elisp
(defvar zz 3 "ガンダムの名前")
```

このように書いた場合、 `zz` にカーソルを置かれると、説明がエコーエリアに表示される。  

```text
zz
```


## defconst {#defconst}

`defconst` は `const` とつくように変数に再代入できないような定数を使うときに使用する。しかしruntimeでは `defconst` も `defvar` も違いはない。  
defcontでつくった変数に `setq` をつかって再代入することができてしまう。  

```elisp
(defconst pai 3.14)
pai ;; => 3.14
(setq pai 3.14159)
pai ;; => 3.14159
```

いつこの制約が働くかというと、バイトコンパイルしたときである。このときにコンパイルエラーになるのだ。  

## defcustom {#defcustom}

`defcustom` はライブラリを利用するユーザに自由に設定できる変数として用意される。前２つの変数定義は、ライブラリ作者側が使うものに対して、 `defcustom` で定義された変数はライブラリ使用者のための変数になる。これは、関数ではなくマクロである。  

`defvar, defcustom` と同様で第3引数までは同じである。  

-   第1引数は変数名
-   第2引数は初期値初回時のみセットされるため、すでに宣言されていたら初期値はセットされはしない
-   第3引数は変数名の説明

第4引数が、このマクロの特徴となってる。あまりにもこの設定方法がたくさんあるので、また別の機会に整理したい  

```elisp
(defcustom c 0 "description" 
  :type '(integer))

(custom-set-variables '(c 3))

c ;; => 3
```
