+++
title = "レキシカルスコープってなんだ？"
author = ["karuta"]
publishDate = 2021-08-21T00:00:00+09:00
tags = ["elisp", "emacs"]
draft = true
+++

elisp登場するレキシカルスコープというもの。他の言語でもあるみたいだが、  
よくわからないので整理しておく。  

<!--more-->  

レキシカルスコープと対になるのがダイナミックスコープであり、  
elispはデフォルトがダイナミックスコープである。  

そのため次のコードが奇妙な挙動になる。  

```elisp
(defun f1 (func)
  (let ((v 'internal))
    (funcall func)))

(let ((v 'external))
  (f1 (lambda () v)))
;; => internal
```

2つ目のS式ではvに'externalを束縛して、それを匿名関数の第一引数として利用してる。  
そのvがf1関数内のletによって上書きされて、最終的にはinternalが出力される。  
これがダイナミックスコープである。  

一方これをレキシカルスコープで使用するとexternalを出力するようになる。  

```elisp
(defun f1 (func)
  (let ((v 'internal))
    (funcall func)))

(lexical-let ((v 'external))
  (f1 (lambda () v)))
;; => external
```

f1関数内の変数はその内部でしか生きないので、externalが出力される。  

わかったようでわからないが、  
要は勝手に変数が上書きされてしまうのを防ぐことができるのがレキシカルスコープと考えられる。  

関数型プロラミングで使用されるクロージャ(closure)がどのような挙動するのかを考えよう。  

```elisp
(defun addx (x)
  (lambda (y) (+ x y)))

(funcall (addx 1) 2)
;; => 4
```

`addx` 関数は引数を与えられると、その引数を固定してクロージャ関数である。  
クロージャならば、 `(addx 1)` として1が渡ってるので1で固定されてfuncallで渡された2の加算結果の3が出力されることを期待できる。  
しかし結果は4になるのだ。これはaddxを呼び出す前にxを別の値で束縛した場合、xを上書きしてしまうからである。  

どうしてこうなるかというと、 `(let ((x 2)))` というletを宣言することで、  
このlet内ではxは2ですよと束縛され、addxもlet内にある関数であるため同じくxを2として判断してしまう。  

これがダイナミックスコープのちからでもあり、非常に怖いところとも呼べる。  
ダイナミックスコープが良いときあるのかわからんが、こういうものだと知っておこう。  

このクロージャを意図通りに動かすにはどうすればいいのだろうか？  

ファイル先頭にこれを記述することである  

```elisp
;; -*- lexical-binding: t -*-

(defun addx (x)
  (lambda (y) (+ x y)))     
```

こうすれば先の結果は3となる。
